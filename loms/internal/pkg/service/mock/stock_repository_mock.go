// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/pkg/service.stockRepository -o stock_repository_mock_test.go -n StockRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements service.stockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySku          func(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error)
	inspectFuncGetBySku   func(ctx context.Context, p1 model.ProductSku)
	afterGetBySkuCounter  uint64
	beforeGetBySkuCounter uint64
	GetBySkuMock          mStockRepositoryMockGetBySku

	funcReserve          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserve   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockRepositoryMockReserve

	funcReserveCancel          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserveCancel   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStockRepositoryMockReserveCancel

	funcReserveRemove          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserveRemove   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockRepositoryMockReserveRemove
}

// NewStockRepositoryMock returns a mock for service.stockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySkuMock = mStockRepositoryMockGetBySku{mock: m}
	m.GetBySkuMock.callArgs = []*StockRepositoryMockGetBySkuParams{}

	m.ReserveMock = mStockRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockRepositoryMockReserveParams{}

	m.ReserveCancelMock = mStockRepositoryMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StockRepositoryMockReserveCancelParams{}

	m.ReserveRemoveMock = mStockRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockRepositoryMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetBySku struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetBySkuExpectation
	expectations       []*StockRepositoryMockGetBySkuExpectation

	callArgs []*StockRepositoryMockGetBySkuParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockGetBySkuExpectation specifies expectation struct of the stockRepository.GetBySku
type StockRepositoryMockGetBySkuExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockGetBySkuParams
	paramPtrs *StockRepositoryMockGetBySkuParamPtrs
	results   *StockRepositoryMockGetBySkuResults
	Counter   uint64
}

// StockRepositoryMockGetBySkuParams contains parameters of the stockRepository.GetBySku
type StockRepositoryMockGetBySkuParams struct {
	ctx context.Context
	p1  model.ProductSku
}

// StockRepositoryMockGetBySkuParamPtrs contains pointers to parameters of the stockRepository.GetBySku
type StockRepositoryMockGetBySkuParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
}

// StockRepositoryMockGetBySkuResults contains results of the stockRepository.GetBySku
type StockRepositoryMockGetBySkuResults struct {
	u1  uint64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySku *mStockRepositoryMockGetBySku) Optional() *mStockRepositoryMockGetBySku {
	mmGetBySku.optional = true
	return mmGetBySku
}

// Expect sets up expected params for stockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Expect(ctx context.Context, p1 model.ProductSku) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{}
	}

	if mmGetBySku.defaultExpectation.paramPtrs != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by ExpectParams functions")
	}

	mmGetBySku.defaultExpectation.params = &StockRepositoryMockGetBySkuParams{ctx, p1}
	for _, e := range mmGetBySku.expectations {
		if minimock.Equal(e.params, mmGetBySku.defaultExpectation.params) {
			mmGetBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySku.defaultExpectation.params)
		}
	}

	return mmGetBySku
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{}
	}

	if mmGetBySku.defaultExpectation.params != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Expect")
	}

	if mmGetBySku.defaultExpectation.paramPtrs == nil {
		mmGetBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySkuParamPtrs{}
	}
	mmGetBySku.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBySku
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{}
	}

	if mmGetBySku.defaultExpectation.params != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Expect")
	}

	if mmGetBySku.defaultExpectation.paramPtrs == nil {
		mmGetBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySkuParamPtrs{}
	}
	mmGetBySku.defaultExpectation.paramPtrs.p1 = &p1

	return mmGetBySku
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Inspect(f func(ctx context.Context, p1 model.ProductSku)) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.inspectFuncGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetBySku")
	}

	mmGetBySku.mock.inspectFuncGetBySku = f

	return mmGetBySku
}

// Return sets up results that will be returned by stockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Return(u1 uint64, err error) *StockRepositoryMock {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{mock: mmGetBySku.mock}
	}
	mmGetBySku.defaultExpectation.results = &StockRepositoryMockGetBySkuResults{u1, err}
	return mmGetBySku.mock
}

// Set uses given function f to mock the stockRepository.GetBySku method
func (mmGetBySku *mStockRepositoryMockGetBySku) Set(f func(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error)) *StockRepositoryMock {
	if mmGetBySku.defaultExpectation != nil {
		mmGetBySku.mock.t.Fatalf("Default expectation is already set for the stockRepository.GetBySku method")
	}

	if len(mmGetBySku.expectations) > 0 {
		mmGetBySku.mock.t.Fatalf("Some expectations are already set for the stockRepository.GetBySku method")
	}

	mmGetBySku.mock.funcGetBySku = f
	return mmGetBySku.mock
}

// When sets expectation for the stockRepository.GetBySku which will trigger the result defined by the following
// Then helper
func (mmGetBySku *mStockRepositoryMockGetBySku) When(ctx context.Context, p1 model.ProductSku) *StockRepositoryMockGetBySkuExpectation {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetBySkuExpectation{
		mock:   mmGetBySku.mock,
		params: &StockRepositoryMockGetBySkuParams{ctx, p1},
	}
	mmGetBySku.expectations = append(mmGetBySku.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.GetBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetBySkuExpectation) Then(u1 uint64, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetBySkuResults{u1, err}
	return e.mock
}

// Times sets number of times stockRepository.GetBySku should be invoked
func (mmGetBySku *mStockRepositoryMockGetBySku) Times(n uint64) *mStockRepositoryMockGetBySku {
	if n == 0 {
		mmGetBySku.mock.t.Fatalf("Times of StockRepositoryMock.GetBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySku.expectedInvocations, n)
	return mmGetBySku
}

func (mmGetBySku *mStockRepositoryMockGetBySku) invocationsDone() bool {
	if len(mmGetBySku.expectations) == 0 && mmGetBySku.defaultExpectation == nil && mmGetBySku.mock.funcGetBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySku.mock.afterGetBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySku implements service.stockRepository
func (mmGetBySku *StockRepositoryMock) GetBySku(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetBySku.beforeGetBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySku.afterGetBySkuCounter, 1)

	if mmGetBySku.inspectFuncGetBySku != nil {
		mmGetBySku.inspectFuncGetBySku(ctx, p1)
	}

	mm_params := StockRepositoryMockGetBySkuParams{ctx, p1}

	// Record call args
	mmGetBySku.GetBySkuMock.mutex.Lock()
	mmGetBySku.GetBySkuMock.callArgs = append(mmGetBySku.GetBySkuMock.callArgs, &mm_params)
	mmGetBySku.GetBySkuMock.mutex.Unlock()

	for _, e := range mmGetBySku.GetBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySku.GetBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySku.GetBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySku.GetBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySku.GetBySkuMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetBySkuParams{ctx, p1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySku.t.Errorf("StockRepositoryMock.GetBySku got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmGetBySku.t.Errorf("StockRepositoryMock.GetBySku got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySku.t.Errorf("StockRepositoryMock.GetBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySku.GetBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySku.t.Fatal("No results are set for the StockRepositoryMock.GetBySku")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySku.funcGetBySku != nil {
		return mmGetBySku.funcGetBySku(ctx, p1)
	}
	mmGetBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetBySku. %v %v", ctx, p1)
	return
}

// GetBySkuAfterCounter returns a count of finished StockRepositoryMock.GetBySku invocations
func (mmGetBySku *StockRepositoryMock) GetBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.afterGetBySkuCounter)
}

// GetBySkuBeforeCounter returns a count of StockRepositoryMock.GetBySku invocations
func (mmGetBySku *StockRepositoryMock) GetBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.beforeGetBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySku *mStockRepositoryMockGetBySku) Calls() []*StockRepositoryMockGetBySkuParams {
	mmGetBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetBySkuParams, len(mmGetBySku.callArgs))
	copy(argCopy, mmGetBySku.callArgs)

	mmGetBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySkuDone returns true if the count of the GetBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetBySkuDone() bool {
	if m.GetBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySkuMock.invocationsDone()
}

// MinimockGetBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetBySkuInspect() {
	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySku with params: %#v", *e.params)
		}
	}

	afterGetBySkuCounter := mm_atomic.LoadUint64(&m.afterGetBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuMock.defaultExpectation != nil && afterGetBySkuCounter < 1 {
		if m.GetBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.GetBySku")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySku with params: %#v", *m.GetBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySku != nil && afterGetBySkuCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.GetBySku")
	}

	if !m.GetBySkuMock.invocationsDone() && afterGetBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetBySku but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySkuMock.expectedInvocations), afterGetBySkuCounter)
	}
}

type mStockRepositoryMockReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveExpectation
	expectations       []*StockRepositoryMockReserveExpectation

	callArgs []*StockRepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveExpectation specifies expectation struct of the stockRepository.Reserve
type StockRepositoryMockReserveExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveParams
	paramPtrs *StockRepositoryMockReserveParamPtrs
	results   *StockRepositoryMockReserveResults
	Counter   uint64
}

// StockRepositoryMockReserveParams contains parameters of the stockRepository.Reserve
type StockRepositoryMockReserveParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveParamPtrs contains pointers to parameters of the stockRepository.Reserve
type StockRepositoryMockReserveParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveResults contains results of the stockRepository.Reserve
type StockRepositoryMockReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockRepositoryMockReserve) Optional() *mStockRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockRepositoryMockReserveParams{ctx, p1, u1}
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserve
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserve
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Return(err error) *StockRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockRepositoryMockReserveResults{err}
	return mmReserve.mock
}

// Set uses given function f to mock the stockRepository.Reserve method
func (mmReserve *mStockRepositoryMockReserve) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the stockRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the stockRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	return mmReserve.mock
}

// When sets expectation for the stockRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockRepositoryMockReserve) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveExpectation{
		mock:   mmReserve.mock,
		params: &StockRepositoryMockReserveParams{ctx, p1, u1},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveResults{err}
	return e.mock
}

// Times sets number of times stockRepository.Reserve should be invoked
func (mmReserve *mStockRepositoryMockReserve) Times(n uint64) *mStockRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockRepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	return mmReserve
}

func (mmReserve *mStockRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements service.stockRepository
func (mmReserve *StockRepositoryMock) Reserve(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveParams{ctx, p1, u1}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, p1, u1)
	}
	mmReserve.t.Fatalf("Unexpected call to StockRepositoryMock.Reserve. %v %v %v", ctx, p1, u1)
	return
}

// ReserveAfterCounter returns a count of finished StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockRepositoryMockReserve) Calls() []*StockRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.Reserve")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.Reserve")
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Reserve but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), afterReserveCounter)
	}
}

type mStockRepositoryMockReserveCancel struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveCancelExpectation
	expectations       []*StockRepositoryMockReserveCancelExpectation

	callArgs []*StockRepositoryMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveCancelExpectation specifies expectation struct of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveCancelParams
	paramPtrs *StockRepositoryMockReserveCancelParamPtrs
	results   *StockRepositoryMockReserveCancelResults
	Counter   uint64
}

// StockRepositoryMockReserveCancelParams contains parameters of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveCancelParamPtrs contains pointers to parameters of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveCancelResults contains results of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Optional() *mStockRepositoryMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StockRepositoryMockReserveCancelParams{ctx, p1, u1}
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveCancel
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserveCancel
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Return(err error) *StockRepositoryMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StockRepositoryMockReserveCancelResults{err}
	return mmReserveCancel.mock
}

// Set uses given function f to mock the stockRepository.ReserveCancel method
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the stockRepository.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the stockRepository.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	return mmReserveCancel.mock
}

// When sets expectation for the stockRepository.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStockRepositoryMockReserveCancel) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveCancelExpectation{
		mock:   mmReserveCancel.mock,
		params: &StockRepositoryMockReserveCancelParams{ctx, p1, u1},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveCancelExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times stockRepository.ReserveCancel should be invoked
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Times(n uint64) *mStockRepositoryMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StockRepositoryMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	return mmReserveCancel
}

func (mmReserveCancel *mStockRepositoryMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements service.stockRepository
func (mmReserveCancel *StockRepositoryMock) ReserveCancel(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveCancelParams{ctx, p1, u1}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveCancelParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StockRepositoryMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, p1, u1)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveCancel. %v %v %v", ctx, p1, u1)
	return
}

// ReserveCancelAfterCounter returns a count of finished StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Calls() []*StockRepositoryMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel with params: %#v", *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.ReserveCancel")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel with params: %#v", *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.ReserveCancel")
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveCancel but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), afterReserveCancelCounter)
	}
}

type mStockRepositoryMockReserveRemove struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveRemoveExpectation
	expectations       []*StockRepositoryMockReserveRemoveExpectation

	callArgs []*StockRepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveRemoveExpectation specifies expectation struct of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveRemoveParams
	paramPtrs *StockRepositoryMockReserveRemoveParamPtrs
	results   *StockRepositoryMockReserveRemoveResults
	Counter   uint64
}

// StockRepositoryMockReserveRemoveParams contains parameters of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveRemoveResults contains results of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Optional() *mStockRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockRepositoryMockReserveRemoveParams{ctx, p1, u1}
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveRemove
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserveRemove
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Return(err error) *StockRepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockRepositoryMockReserveRemoveResults{err}
	return mmReserveRemove.mock
}

// Set uses given function f to mock the stockRepository.ReserveRemove method
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the stockRepository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the stockRepository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	return mmReserveRemove.mock
}

// When sets expectation for the stockRepository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockRepositoryMockReserveRemove) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveRemoveExpectation{
		mock:   mmReserveRemove.mock,
		params: &StockRepositoryMockReserveRemoveParams{ctx, p1, u1},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveRemoveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times stockRepository.ReserveRemove should be invoked
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Times(n uint64) *mStockRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockRepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	return mmReserveRemove
}

func (mmReserveRemove *mStockRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements service.stockRepository
func (mmReserveRemove *StockRepositoryMock) ReserveRemove(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveRemoveParams{ctx, p1, u1}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveRemoveParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockRepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, p1, u1)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveRemove. %v %v %v", ctx, p1, u1)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Calls() []*StockRepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove with params: %#v", *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.ReserveRemove")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove with params: %#v", *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.ReserveRemove")
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveRemove but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySkuInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySkuDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone()
}
