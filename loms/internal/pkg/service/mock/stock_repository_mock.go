// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/pkg/service.stockRepository -o stock_repository_mock_test.go -n StockRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements service.stockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStocksBySku          func(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error)
	inspectFuncGetStocksBySku   func(ctx context.Context, p1 model.ProductSku)
	afterGetStocksBySkuCounter  uint64
	beforeGetStocksBySkuCounter uint64
	GetStocksBySkuMock          mStockRepositoryMockGetStocksBySku

	funcReserve          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserve   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockRepositoryMockReserve

	funcReserveCancel          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserveCancel   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStockRepositoryMockReserveCancel

	funcReserveRemove          func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)
	inspectFuncReserveRemove   func(ctx context.Context, p1 model.ProductSku, u1 uint16)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockRepositoryMockReserveRemove
}

// NewStockRepositoryMock returns a mock for service.stockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStocksBySkuMock = mStockRepositoryMockGetStocksBySku{mock: m}
	m.GetStocksBySkuMock.callArgs = []*StockRepositoryMockGetStocksBySkuParams{}

	m.ReserveMock = mStockRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockRepositoryMockReserveParams{}

	m.ReserveCancelMock = mStockRepositoryMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StockRepositoryMockReserveCancelParams{}

	m.ReserveRemoveMock = mStockRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockRepositoryMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetStocksBySku struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetStocksBySkuExpectation
	expectations       []*StockRepositoryMockGetStocksBySkuExpectation

	callArgs []*StockRepositoryMockGetStocksBySkuParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockGetStocksBySkuExpectation specifies expectation struct of the stockRepository.GetStocksBySku
type StockRepositoryMockGetStocksBySkuExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockGetStocksBySkuParams
	paramPtrs *StockRepositoryMockGetStocksBySkuParamPtrs
	results   *StockRepositoryMockGetStocksBySkuResults
	Counter   uint64
}

// StockRepositoryMockGetStocksBySkuParams contains parameters of the stockRepository.GetStocksBySku
type StockRepositoryMockGetStocksBySkuParams struct {
	ctx context.Context
	p1  model.ProductSku
}

// StockRepositoryMockGetStocksBySkuParamPtrs contains pointers to parameters of the stockRepository.GetStocksBySku
type StockRepositoryMockGetStocksBySkuParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
}

// StockRepositoryMockGetStocksBySkuResults contains results of the stockRepository.GetStocksBySku
type StockRepositoryMockGetStocksBySkuResults struct {
	u1  uint64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Optional() *mStockRepositoryMockGetStocksBySku {
	mmGetStocksBySku.optional = true
	return mmGetStocksBySku
}

// Expect sets up expected params for stockRepository.GetStocksBySku
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Expect(ctx context.Context, p1 model.ProductSku) *mStockRepositoryMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &StockRepositoryMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by ExpectParams functions")
	}

	mmGetStocksBySku.defaultExpectation.params = &StockRepositoryMockGetStocksBySkuParams{ctx, p1}
	for _, e := range mmGetStocksBySku.expectations {
		if minimock.Equal(e.params, mmGetStocksBySku.defaultExpectation.params) {
			mmGetStocksBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocksBySku.defaultExpectation.params)
		}
	}

	return mmGetStocksBySku
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.GetStocksBySku
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &StockRepositoryMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetStocksBySku
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.GetStocksBySku
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &StockRepositoryMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.p1 = &p1

	return mmGetStocksBySku
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.GetStocksBySku
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Inspect(f func(ctx context.Context, p1 model.ProductSku)) *mStockRepositoryMockGetStocksBySku {
	if mmGetStocksBySku.mock.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetStocksBySku")
	}

	mmGetStocksBySku.mock.inspectFuncGetStocksBySku = f

	return mmGetStocksBySku
}

// Return sets up results that will be returned by stockRepository.GetStocksBySku
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Return(u1 uint64, err error) *StockRepositoryMock {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &StockRepositoryMockGetStocksBySkuExpectation{mock: mmGetStocksBySku.mock}
	}
	mmGetStocksBySku.defaultExpectation.results = &StockRepositoryMockGetStocksBySkuResults{u1, err}
	return mmGetStocksBySku.mock
}

// Set uses given function f to mock the stockRepository.GetStocksBySku method
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Set(f func(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error)) *StockRepositoryMock {
	if mmGetStocksBySku.defaultExpectation != nil {
		mmGetStocksBySku.mock.t.Fatalf("Default expectation is already set for the stockRepository.GetStocksBySku method")
	}

	if len(mmGetStocksBySku.expectations) > 0 {
		mmGetStocksBySku.mock.t.Fatalf("Some expectations are already set for the stockRepository.GetStocksBySku method")
	}

	mmGetStocksBySku.mock.funcGetStocksBySku = f
	return mmGetStocksBySku.mock
}

// When sets expectation for the stockRepository.GetStocksBySku which will trigger the result defined by the following
// Then helper
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) When(ctx context.Context, p1 model.ProductSku) *StockRepositoryMockGetStocksBySkuExpectation {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("StockRepositoryMock.GetStocksBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetStocksBySkuExpectation{
		mock:   mmGetStocksBySku.mock,
		params: &StockRepositoryMockGetStocksBySkuParams{ctx, p1},
	}
	mmGetStocksBySku.expectations = append(mmGetStocksBySku.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.GetStocksBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetStocksBySkuExpectation) Then(u1 uint64, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetStocksBySkuResults{u1, err}
	return e.mock
}

// Times sets number of times stockRepository.GetStocksBySku should be invoked
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Times(n uint64) *mStockRepositoryMockGetStocksBySku {
	if n == 0 {
		mmGetStocksBySku.mock.t.Fatalf("Times of StockRepositoryMock.GetStocksBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStocksBySku.expectedInvocations, n)
	return mmGetStocksBySku
}

func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) invocationsDone() bool {
	if len(mmGetStocksBySku.expectations) == 0 && mmGetStocksBySku.defaultExpectation == nil && mmGetStocksBySku.mock.funcGetStocksBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.mock.afterGetStocksBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStocksBySku implements service.stockRepository
func (mmGetStocksBySku *StockRepositoryMock) GetStocksBySku(ctx context.Context, p1 model.ProductSku) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter, 1)

	if mmGetStocksBySku.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.inspectFuncGetStocksBySku(ctx, p1)
	}

	mm_params := StockRepositoryMockGetStocksBySkuParams{ctx, p1}

	// Record call args
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Lock()
	mmGetStocksBySku.GetStocksBySkuMock.callArgs = append(mmGetStocksBySku.GetStocksBySkuMock.callArgs, &mm_params)
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Unlock()

	for _, e := range mmGetStocksBySku.GetStocksBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetStocksBySkuParams{ctx, p1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStocksBySku.t.Errorf("StockRepositoryMock.GetStocksBySku got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmGetStocksBySku.t.Errorf("StockRepositoryMock.GetStocksBySku got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocksBySku.t.Errorf("StockRepositoryMock.GetStocksBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocksBySku.t.Fatal("No results are set for the StockRepositoryMock.GetStocksBySku")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetStocksBySku.funcGetStocksBySku != nil {
		return mmGetStocksBySku.funcGetStocksBySku(ctx, p1)
	}
	mmGetStocksBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetStocksBySku. %v %v", ctx, p1)
	return
}

// GetStocksBySkuAfterCounter returns a count of finished StockRepositoryMock.GetStocksBySku invocations
func (mmGetStocksBySku *StockRepositoryMock) GetStocksBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter)
}

// GetStocksBySkuBeforeCounter returns a count of StockRepositoryMock.GetStocksBySku invocations
func (mmGetStocksBySku *StockRepositoryMock) GetStocksBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetStocksBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocksBySku *mStockRepositoryMockGetStocksBySku) Calls() []*StockRepositoryMockGetStocksBySkuParams {
	mmGetStocksBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetStocksBySkuParams, len(mmGetStocksBySku.callArgs))
	copy(argCopy, mmGetStocksBySku.callArgs)

	mmGetStocksBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksBySkuDone returns true if the count of the GetStocksBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetStocksBySkuDone() bool {
	if m.GetStocksBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStocksBySkuMock.invocationsDone()
}

// MinimockGetStocksBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetStocksBySkuInspect() {
	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySku with params: %#v", *e.params)
		}
	}

	afterGetStocksBySkuCounter := mm_atomic.LoadUint64(&m.afterGetStocksBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksBySkuMock.defaultExpectation != nil && afterGetStocksBySkuCounter < 1 {
		if m.GetStocksBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.GetStocksBySku")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySku with params: %#v", *m.GetStocksBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocksBySku != nil && afterGetStocksBySkuCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.GetStocksBySku")
	}

	if !m.GetStocksBySkuMock.invocationsDone() && afterGetStocksBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetStocksBySku but found %d calls",
			mm_atomic.LoadUint64(&m.GetStocksBySkuMock.expectedInvocations), afterGetStocksBySkuCounter)
	}
}

type mStockRepositoryMockReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveExpectation
	expectations       []*StockRepositoryMockReserveExpectation

	callArgs []*StockRepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveExpectation specifies expectation struct of the stockRepository.Reserve
type StockRepositoryMockReserveExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveParams
	paramPtrs *StockRepositoryMockReserveParamPtrs
	results   *StockRepositoryMockReserveResults
	Counter   uint64
}

// StockRepositoryMockReserveParams contains parameters of the stockRepository.Reserve
type StockRepositoryMockReserveParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveParamPtrs contains pointers to parameters of the stockRepository.Reserve
type StockRepositoryMockReserveParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveResults contains results of the stockRepository.Reserve
type StockRepositoryMockReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockRepositoryMockReserve) Optional() *mStockRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockRepositoryMockReserveParams{ctx, p1, u1}
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserve
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserve
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by stockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Return(err error) *StockRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockRepositoryMockReserveResults{err}
	return mmReserve.mock
}

// Set uses given function f to mock the stockRepository.Reserve method
func (mmReserve *mStockRepositoryMockReserve) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the stockRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the stockRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	return mmReserve.mock
}

// When sets expectation for the stockRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockRepositoryMockReserve) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveExpectation{
		mock:   mmReserve.mock,
		params: &StockRepositoryMockReserveParams{ctx, p1, u1},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveResults{err}
	return e.mock
}

// Times sets number of times stockRepository.Reserve should be invoked
func (mmReserve *mStockRepositoryMockReserve) Times(n uint64) *mStockRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockRepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	return mmReserve
}

func (mmReserve *mStockRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements service.stockRepository
func (mmReserve *StockRepositoryMock) Reserve(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveParams{ctx, p1, u1}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, p1, u1)
	}
	mmReserve.t.Fatalf("Unexpected call to StockRepositoryMock.Reserve. %v %v %v", ctx, p1, u1)
	return
}

// ReserveAfterCounter returns a count of finished StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockRepositoryMockReserve) Calls() []*StockRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.Reserve")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.Reserve")
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Reserve but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), afterReserveCounter)
	}
}

type mStockRepositoryMockReserveCancel struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveCancelExpectation
	expectations       []*StockRepositoryMockReserveCancelExpectation

	callArgs []*StockRepositoryMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveCancelExpectation specifies expectation struct of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveCancelParams
	paramPtrs *StockRepositoryMockReserveCancelParamPtrs
	results   *StockRepositoryMockReserveCancelResults
	Counter   uint64
}

// StockRepositoryMockReserveCancelParams contains parameters of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveCancelParamPtrs contains pointers to parameters of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveCancelResults contains results of the stockRepository.ReserveCancel
type StockRepositoryMockReserveCancelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Optional() *mStockRepositoryMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StockRepositoryMockReserveCancelParams{ctx, p1, u1}
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveCancel
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserveCancel
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by stockRepository.ReserveCancel
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Return(err error) *StockRepositoryMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockRepositoryMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StockRepositoryMockReserveCancelResults{err}
	return mmReserveCancel.mock
}

// Set uses given function f to mock the stockRepository.ReserveCancel method
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the stockRepository.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the stockRepository.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	return mmReserveCancel.mock
}

// When sets expectation for the stockRepository.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStockRepositoryMockReserveCancel) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockRepositoryMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveCancelExpectation{
		mock:   mmReserveCancel.mock,
		params: &StockRepositoryMockReserveCancelParams{ctx, p1, u1},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveCancelExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times stockRepository.ReserveCancel should be invoked
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Times(n uint64) *mStockRepositoryMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StockRepositoryMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	return mmReserveCancel
}

func (mmReserveCancel *mStockRepositoryMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements service.stockRepository
func (mmReserveCancel *StockRepositoryMock) ReserveCancel(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveCancelParams{ctx, p1, u1}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveCancelParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StockRepositoryMock.ReserveCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StockRepositoryMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, p1, u1)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveCancel. %v %v %v", ctx, p1, u1)
	return
}

// ReserveCancelAfterCounter returns a count of finished StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StockRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *StockRepositoryMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStockRepositoryMockReserveCancel) Calls() []*StockRepositoryMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel with params: %#v", *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.ReserveCancel")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveCancel with params: %#v", *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.ReserveCancel")
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveCancel but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), afterReserveCancelCounter)
	}
}

type mStockRepositoryMockReserveRemove struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveRemoveExpectation
	expectations       []*StockRepositoryMockReserveRemoveExpectation

	callArgs []*StockRepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockRepositoryMockReserveRemoveExpectation specifies expectation struct of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectation struct {
	mock      *StockRepositoryMock
	params    *StockRepositoryMockReserveRemoveParams
	paramPtrs *StockRepositoryMockReserveRemoveParamPtrs
	results   *StockRepositoryMockReserveRemoveResults
	Counter   uint64
}

// StockRepositoryMockReserveRemoveParams contains parameters of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParams struct {
	ctx context.Context
	p1  model.ProductSku
	u1  uint16
}

// StockRepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParamPtrs struct {
	ctx *context.Context
	p1  *model.ProductSku
	u1  *uint16
}

// StockRepositoryMockReserveRemoveResults contains results of the stockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Optional() *mStockRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Expect(ctx context.Context, p1 model.ProductSku, u1 uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockRepositoryMockReserveRemoveParams{ctx, p1, u1}
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveRemove
}

// ExpectP1Param2 sets up expected param p1 for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectP1Param2(p1 model.ProductSku) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.p1 = &p1

	return mmReserveRemove
}

// ExpectU1Param3 sets up expected param u1 for stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectU1Param3(u1 uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.u1 = &u1

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, p1 model.ProductSku, u1 uint16)) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by stockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Return(err error) *StockRepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockRepositoryMockReserveRemoveResults{err}
	return mmReserveRemove.mock
}

// Set uses given function f to mock the stockRepository.ReserveRemove method
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Set(f func(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error)) *StockRepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the stockRepository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the stockRepository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	return mmReserveRemove.mock
}

// When sets expectation for the stockRepository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockRepositoryMockReserveRemove) When(ctx context.Context, p1 model.ProductSku, u1 uint16) *StockRepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveRemoveExpectation{
		mock:   mmReserveRemove.mock,
		params: &StockRepositoryMockReserveRemoveParams{ctx, p1, u1},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveRemoveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times stockRepository.ReserveRemove should be invoked
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Times(n uint64) *mStockRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockRepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	return mmReserveRemove
}

func (mmReserveRemove *mStockRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements service.stockRepository
func (mmReserveRemove *StockRepositoryMock) ReserveRemove(ctx context.Context, p1 model.ProductSku, u1 uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, p1, u1)
	}

	mm_params := StockRepositoryMockReserveRemoveParams{ctx, p1, u1}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveRemoveParams{ctx, p1, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p1 != nil && !minimock.Equal(*mm_want_ptrs.p1, mm_got.p1) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter p1, want: %#v, got: %#v%s\n", *mm_want_ptrs.p1, mm_got.p1, minimock.Diff(*mm_want_ptrs.p1, mm_got.p1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockRepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, p1, u1)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveRemove. %v %v %v", ctx, p1, u1)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Calls() []*StockRepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove with params: %#v", *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.ReserveRemove")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove with params: %#v", *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Error("Expected call to StockRepositoryMock.ReserveRemove")
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveRemove but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStocksBySkuInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStocksBySkuDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone()
}
