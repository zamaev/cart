// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/pkg/service.orderRepository -o order_repository_mock_test.go -n OrderRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements service.orderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, o1 model.Order) (o2 model.OrderID)
	inspectFuncCreate   func(ctx context.Context, o1 model.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderRepositoryMockCreate

	funcGetById          func(ctx context.Context, o1 model.OrderID) (o2 model.Order, err error)
	inspectFuncGetById   func(ctx context.Context, o1 model.OrderID)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mOrderRepositoryMockGetById

	funcSetStatus          func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error)
	inspectFuncSetStatus   func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepositoryMockSetStatus
}

// NewOrderRepositoryMock returns a mock for service.orderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderRepositoryMockCreateParams{}

	m.GetByIdMock = mOrderRepositoryMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*OrderRepositoryMockGetByIdParams{}

	m.SetStatusMock = mOrderRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepositoryMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockCreate struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateExpectation
	expectations       []*OrderRepositoryMockCreateExpectation

	callArgs []*OrderRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepositoryMockCreateExpectation specifies expectation struct of the orderRepository.Create
type OrderRepositoryMockCreateExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockCreateParams
	paramPtrs *OrderRepositoryMockCreateParamPtrs
	results   *OrderRepositoryMockCreateResults
	Counter   uint64
}

// OrderRepositoryMockCreateParams contains parameters of the orderRepository.Create
type OrderRepositoryMockCreateParams struct {
	ctx context.Context
	o1  model.Order
}

// OrderRepositoryMockCreateParamPtrs contains pointers to parameters of the orderRepository.Create
type OrderRepositoryMockCreateParamPtrs struct {
	ctx *context.Context
	o1  *model.Order
}

// OrderRepositoryMockCreateResults contains results of the orderRepository.Create
type OrderRepositoryMockCreateResults struct {
	o2 model.OrderID
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderRepositoryMockCreate) Optional() *mOrderRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for orderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Expect(ctx context.Context, o1 model.Order) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderRepositoryMockCreateParams{ctx, o1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectO1Param2 sets up expected param o1 for orderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) ExpectO1Param2(o1 model.Order) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.o1 = &o1

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Inspect(f func(ctx context.Context, o1 model.Order)) *mOrderRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by orderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Return(o2 model.OrderID) *OrderRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderRepositoryMockCreateResults{o2}
	return mmCreate.mock
}

// Set uses given function f to mock the orderRepository.Create method
func (mmCreate *mOrderRepositoryMockCreate) Set(f func(ctx context.Context, o1 model.Order) (o2 model.OrderID)) *OrderRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the orderRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the orderRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the orderRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderRepositoryMockCreate) When(ctx context.Context, o1 model.Order) *OrderRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &OrderRepositoryMockCreateParams{ctx, o1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateExpectation) Then(o2 model.OrderID) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateResults{o2}
	return e.mock
}

// Times sets number of times orderRepository.Create should be invoked
func (mmCreate *mOrderRepositoryMockCreate) Times(n uint64) *mOrderRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mOrderRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements service.orderRepository
func (mmCreate *OrderRepositoryMock) Create(ctx context.Context, o1 model.Order) (o2 model.OrderID) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, o1)
	}

	mm_params := OrderRepositoryMockCreateParams{ctx, o1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockCreateParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderRepositoryMock.Create")
		}
		return (*mm_results).o2
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, o1)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderRepositoryMock.Create. %v %v", ctx, o1)
	return
}

// CreateAfterCounter returns a count of finished OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderRepositoryMockCreate) Calls() []*OrderRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mOrderRepositoryMockGetById struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByIdExpectation
	expectations       []*OrderRepositoryMockGetByIdExpectation

	callArgs []*OrderRepositoryMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepositoryMockGetByIdExpectation specifies expectation struct of the orderRepository.GetById
type OrderRepositoryMockGetByIdExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockGetByIdParams
	paramPtrs *OrderRepositoryMockGetByIdParamPtrs
	results   *OrderRepositoryMockGetByIdResults
	Counter   uint64
}

// OrderRepositoryMockGetByIdParams contains parameters of the orderRepository.GetById
type OrderRepositoryMockGetByIdParams struct {
	ctx context.Context
	o1  model.OrderID
}

// OrderRepositoryMockGetByIdParamPtrs contains pointers to parameters of the orderRepository.GetById
type OrderRepositoryMockGetByIdParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderID
}

// OrderRepositoryMockGetByIdResults contains results of the orderRepository.GetById
type OrderRepositoryMockGetByIdResults struct {
	o2  model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mOrderRepositoryMockGetById) Optional() *mOrderRepositoryMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for orderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Expect(ctx context.Context, o1 model.OrderID) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &OrderRepositoryMockGetByIdParams{ctx, o1}
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetById
}

// ExpectO1Param2 sets up expected param o1 for orderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) ExpectO1Param2(o1 model.OrderID) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.o1 = &o1

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Inspect(f func(ctx context.Context, o1 model.OrderID)) *mOrderRepositoryMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by orderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Return(o2 model.Order, err error) *OrderRepositoryMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &OrderRepositoryMockGetByIdResults{o2, err}
	return mmGetById.mock
}

// Set uses given function f to mock the orderRepository.GetById method
func (mmGetById *mOrderRepositoryMockGetById) Set(f func(ctx context.Context, o1 model.OrderID) (o2 model.Order, err error)) *OrderRepositoryMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetById method")
	}

	mmGetById.mock.funcGetById = f
	return mmGetById.mock
}

// When sets expectation for the orderRepository.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mOrderRepositoryMockGetById) When(ctx context.Context, o1 model.OrderID) *OrderRepositoryMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByIdExpectation{
		mock:   mmGetById.mock,
		params: &OrderRepositoryMockGetByIdParams{ctx, o1},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetById return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByIdExpectation) Then(o2 model.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByIdResults{o2, err}
	return e.mock
}

// Times sets number of times orderRepository.GetById should be invoked
func (mmGetById *mOrderRepositoryMockGetById) Times(n uint64) *mOrderRepositoryMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of OrderRepositoryMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	return mmGetById
}

func (mmGetById *mOrderRepositoryMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements service.orderRepository
func (mmGetById *OrderRepositoryMock) GetById(ctx context.Context, o1 model.OrderID) (o2 model.Order, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, o1)
	}

	mm_params := OrderRepositoryMockGetByIdParams{ctx, o1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByIdParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the OrderRepositoryMock.GetById")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, o1)
	}
	mmGetById.t.Fatalf("Unexpected call to OrderRepositoryMock.GetById. %v %v", ctx, o1)
	return
}

// GetByIdAfterCounter returns a count of finished OrderRepositoryMock.GetById invocations
func (mmGetById *OrderRepositoryMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of OrderRepositoryMock.GetById invocations
func (mmGetById *OrderRepositoryMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mOrderRepositoryMockGetById) Calls() []*OrderRepositoryMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetById with params: %#v", *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetById")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetById with params: %#v", *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetById")
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetById but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), afterGetByIdCounter)
	}
}

type mOrderRepositoryMockSetStatus struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSetStatusExpectation
	expectations       []*OrderRepositoryMockSetStatusExpectation

	callArgs []*OrderRepositoryMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepositoryMockSetStatusExpectation specifies expectation struct of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockSetStatusParams
	paramPtrs *OrderRepositoryMockSetStatusParamPtrs
	results   *OrderRepositoryMockSetStatusResults
	Counter   uint64
}

// OrderRepositoryMockSetStatusParams contains parameters of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusParams struct {
	ctx context.Context
	o1  model.OrderID
	o2  model.OrderStatus
}

// OrderRepositoryMockSetStatusParamPtrs contains pointers to parameters of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderID
	o2  *model.OrderStatus
}

// OrderRepositoryMockSetStatusResults contains results of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderRepositoryMockSetStatus) Optional() *mOrderRepositoryMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Expect(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderRepositoryMockSetStatusParams{ctx, o1, o2}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectO1Param2 sets up expected param o1 for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectO1Param2(o1 model.OrderID) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o1 = &o1

	return mmSetStatus
}

// ExpectO2Param3 sets up expected param o2 for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectO2Param3(o2 model.OrderStatus) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o2 = &o2

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Inspect(f func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus)) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Return(err error) *OrderRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepositoryMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the orderRepository.SetStatus method
func (mmSetStatus *mOrderRepositoryMockSetStatus) Set(f func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error)) *OrderRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the orderRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the orderRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the orderRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepositoryMockSetStatus) When(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) *OrderRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderRepositoryMockSetStatusParams{ctx, o1, o2},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSetStatusExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times orderRepository.SetStatus should be invoked
func (mmSetStatus *mOrderRepositoryMockSetStatus) Times(n uint64) *mOrderRepositoryMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderRepositoryMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderRepositoryMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements service.orderRepository
func (mmSetStatus *OrderRepositoryMock) SetStatus(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, o1, o2)
	}

	mm_params := OrderRepositoryMockSetStatusParams{ctx, o1, o2}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSetStatusParams{ctx, o1, o2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter o1, want: %#v, got: %#v%s\n", *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.o2 != nil && !minimock.Equal(*mm_want_ptrs.o2, mm_got.o2) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter o2, want: %#v, got: %#v%s\n", *mm_want_ptrs.o2, mm_got.o2, minimock.Diff(*mm_want_ptrs.o2, mm_got.o2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, o1, o2)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepositoryMock.SetStatus. %v %v %v", ctx, o1, o2)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepositoryMockSetStatus) Calls() []*OrderRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIdInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockSetStatusDone()
}
