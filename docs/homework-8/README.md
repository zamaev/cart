# Домашние задания по модулю "Паттерны высоконагруженных приложений"

## Основное задание

- Кэш
  - Необходимо добавить in-memory кэш для походов в ProductService ручку http://route256.pavl.uk:8080/docs/#/ProductService/ProductService_GetProduct
  - Клиент с кэшированием должен соответствовать интерфейсу клиента без кэширования
  - Клиент с кэшированием должен принимать обычный клиент в качестве зависимости
  - Клиент с кэшированием должен принимать компонент сохранения и извлечения кэша в качестве зависимости (для удобства
    назовем его Cacher)
  - Реализовать базовую версию компонента сохранения и извлечения кэша (Cacher), одним из следующих способов:
    - 1. Кольцевой буфер
      - при инициализации задается максимальный размер кэша (максимальное количество элементов)
      - при создании аллоцируется map заданного размера и кольцевой буфер
      - map хранит в себе значения по ключу кэширования
      - кольцевой буфер содержит ключи map в порядке вставки. При добавлении нового элемента в кэш необходимо добавить
        ключ в кольцевой буфер и сохранить значение в кэш по этому ключу в map. Если в кольцевом буфере позиция записи
        уже занята (буфер полностью заполнен и мы идем по второму кругу), то ключ, который хранился по данной позиции в
        кольцевом буфере, должен удалиться из map
      - количество элементов в map не превышает размера кольцевого буфера
      - в качестве map использовать шардированную map или sync.map
      - компонент должен принимать опции, с помощью которых можно настроить максимальный размер кэша и количество шардов
        в map (для реализации шардированной map)
      - без передачи опций должны быть предустановлены значения по умолчанию
      - компонент должен быть потокобезопасным и корректно работать при конкурентных запросах
    - 2. LRU двусвязный список
      - При инициализации задается максимальный размер кэша (максимальное количество элементов)
      - Аналогичным образом (как и в случае с кольцевым буфером) создается map для доступа по ключу кэша
      - Вместо кольцевого буфера необходимо использовать двусвязный список (https://pkg.go.dev/container/list или
        аналог)
      - В map в качестве значений хранятся элементы двусвязного списка
      - Если в кэше (в map) нет нужного ключа, то осуществляется получение значения из мастер-системы (ProductService),
        кэш сохраняется и в map, и в начало списка, при этом значение в хвосте списка удаляется из самого списка и из
        map
      - Если ключ уже присутствует в кэше, на любой позиции, то позиция данного ключа перемещается в начало списка,
        никакие элементы не удаляются
      - В каждый момент времени длина списка и размер map не превосходят заданного в конфигурации N
      - Компонент должен принимать опции, с помощью которых можно настроить максимальное количество элементов в кэше и,
        возможно, иные настройки
      - Без передачи опций должны быть предустановлены значения по умолчанию
      - Компонент должен быть потокобезопасным и корректно работать при конкурентных запросах
  - Если в кэше нет нужной информации, то по-прежнему идем в ProductService и сохраняем данные в кэше
- Шардирование
  - Настроить еще один инстанс postgres в docker окружении
  - Настроить выполнение миграций с помощью make и goose, чтобы они отрабатывали на всех шардах
  - Настроить подключения в приложении
  - Создать компонент (назовем ShardManager)
    - компонент позволяет получить подключение к шарду по ключу шардирования
    - компонент принимает функцию шардирования и подключения к шардам
    - функция шардирования принимает значение ключа шардирования и возвращает номер шарда
  - Доработать репозитории таким образом, чтобы новые заказы создавались на каждом из шардов
  - Доработать метод получения заказа по идентификатору, вызов должен обслуживаться запросом к одному из шардов
  - Перевести все ручки, которые создают/изменяют/читают заказы на работу с шардированной БД
  - Для работы со stocks и другими сущностями можно всегда использовать конкретный шард (зафиксировать индекс шарда),
    либо вынести работу с ними в отдельный postgres. Шардировать другие сущности не нужно

## Дополнительное задание

- Кэш
  - Вместо in-memory реализации кэша ProductService GetProduct использовать Redis
    - настроить docker контейнер с Redis
    - настроить конфигурацию приложения и инициировать подключение
    - реализовать интерфейс Cacher с использованием Redis
    - настройки времени жизни и прочего брать из настроек приложения
  - Защитить клиент с кэшированием от обновления кэша для конкретного продукта, пока другой поток выполняет запрос к
    ProductService с этим ProductID
  - Защитить клиент с кэшированием от нескольких одновременных походов к ProductService с одним ProductID: пока
    выполняется запрос в сервис с конкретным ProductID, остальные потоки, запрашивающие этот ProductID, должны дождаться
    ответа и, возможно, записи в кэш
  - Добавить метрики, которые позволят вычислить hit ratio кэша и время ответа для cache hit и cache miss
- Шардирование
  - Реализовать метод получения списка заказов с разных шардов с последующим объединением результатов, заказы должны
    быть упорядочены по ID заказа по убыванию

### Дедлайны сдачи и проверки задания: 
- 27 июля 23:59 (сдача) / 30 июля, 23:59 (проверка)
