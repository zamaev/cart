// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/pkg/service/cart.lomsService -o loms_service_mock_test.go -n LomsServiceMock -p mock

import (
	"context"
	"route256/cart/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LomsServiceMock implements cart.lomsService
type LomsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCreate          func(ctx context.Context, user model.UserId, cart model.Cart) (o1 model.OrderId, err error)
	inspectFuncOrderCreate   func(ctx context.Context, user model.UserId, cart model.Cart)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mLomsServiceMockOrderCreate

	funcStocksInfo          func(ctx context.Context, sku model.ProductSku) (u1 uint64, err error)
	inspectFuncStocksInfo   func(ctx context.Context, sku model.ProductSku)
	afterStocksInfoCounter  uint64
	beforeStocksInfoCounter uint64
	StocksInfoMock          mLomsServiceMockStocksInfo
}

// NewLomsServiceMock returns a mock for cart.lomsService
func NewLomsServiceMock(t minimock.Tester) *LomsServiceMock {
	m := &LomsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCreateMock = mLomsServiceMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*LomsServiceMockOrderCreateParams{}

	m.StocksInfoMock = mLomsServiceMockStocksInfo{mock: m}
	m.StocksInfoMock.callArgs = []*LomsServiceMockStocksInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLomsServiceMockOrderCreate struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockOrderCreateExpectation
	expectations       []*LomsServiceMockOrderCreateExpectation

	callArgs []*LomsServiceMockOrderCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServiceMockOrderCreateExpectation specifies expectation struct of the lomsService.OrderCreate
type LomsServiceMockOrderCreateExpectation struct {
	mock      *LomsServiceMock
	params    *LomsServiceMockOrderCreateParams
	paramPtrs *LomsServiceMockOrderCreateParamPtrs
	results   *LomsServiceMockOrderCreateResults
	Counter   uint64
}

// LomsServiceMockOrderCreateParams contains parameters of the lomsService.OrderCreate
type LomsServiceMockOrderCreateParams struct {
	ctx  context.Context
	user model.UserId
	cart model.Cart
}

// LomsServiceMockOrderCreateParamPtrs contains pointers to parameters of the lomsService.OrderCreate
type LomsServiceMockOrderCreateParamPtrs struct {
	ctx  *context.Context
	user *model.UserId
	cart *model.Cart
}

// LomsServiceMockOrderCreateResults contains results of the lomsService.OrderCreate
type LomsServiceMockOrderCreateResults struct {
	o1  model.OrderId
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreate *mLomsServiceMockOrderCreate) Optional() *mLomsServiceMockOrderCreate {
	mmOrderCreate.optional = true
	return mmOrderCreate
}

// Expect sets up expected params for lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Expect(ctx context.Context, user model.UserId, cart model.Cart) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.paramPtrs != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by ExpectParams functions")
	}

	mmOrderCreate.defaultExpectation.params = &LomsServiceMockOrderCreateParams{ctx, user, cart}
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// ExpectCtxParam1 sets up expected param ctx for lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderCreate
}

// ExpectUserParam2 sets up expected param user for lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) ExpectUserParam2(user model.UserId) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.user = &user

	return mmOrderCreate
}

// ExpectCartParam3 sets up expected param cart for lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) ExpectCartParam3(cart model.Cart) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.cart = &cart

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Inspect(f func(ctx context.Context, user model.UserId, cart model.Cart)) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by lomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Return(o1 model.OrderId, err error) *LomsServiceMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &LomsServiceMockOrderCreateResults{o1, err}
	return mmOrderCreate.mock
}

// Set uses given function f to mock the lomsService.OrderCreate method
func (mmOrderCreate *mLomsServiceMockOrderCreate) Set(f func(ctx context.Context, user model.UserId, cart model.Cart) (o1 model.OrderId, err error)) *LomsServiceMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the lomsService.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the lomsService.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	return mmOrderCreate.mock
}

// When sets expectation for the lomsService.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mLomsServiceMockOrderCreate) When(ctx context.Context, user model.UserId, cart model.Cart) *LomsServiceMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	expectation := &LomsServiceMockOrderCreateExpectation{
		mock:   mmOrderCreate.mock,
		params: &LomsServiceMockOrderCreateParams{ctx, user, cart},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up lomsService.OrderCreate return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockOrderCreateExpectation) Then(o1 model.OrderId, err error) *LomsServiceMock {
	e.results = &LomsServiceMockOrderCreateResults{o1, err}
	return e.mock
}

// Times sets number of times lomsService.OrderCreate should be invoked
func (mmOrderCreate *mLomsServiceMockOrderCreate) Times(n uint64) *mLomsServiceMockOrderCreate {
	if n == 0 {
		mmOrderCreate.mock.t.Fatalf("Times of LomsServiceMock.OrderCreate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreate.expectedInvocations, n)
	return mmOrderCreate
}

func (mmOrderCreate *mLomsServiceMockOrderCreate) invocationsDone() bool {
	if len(mmOrderCreate.expectations) == 0 && mmOrderCreate.defaultExpectation == nil && mmOrderCreate.mock.funcOrderCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreate.mock.afterOrderCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreate implements cart.lomsService
func (mmOrderCreate *LomsServiceMock) OrderCreate(ctx context.Context, user model.UserId, cart model.Cart) (o1 model.OrderId, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, user, cart)
	}

	mm_params := LomsServiceMockOrderCreateParams{ctx, user, cart}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreate.OrderCreateMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockOrderCreateParams{ctx, user, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the LomsServiceMock.OrderCreate")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, user, cart)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to LomsServiceMock.OrderCreate. %v %v %v", ctx, user, cart)
	return
}

// OrderCreateAfterCounter returns a count of finished LomsServiceMock.OrderCreate invocations
func (mmOrderCreate *LomsServiceMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of LomsServiceMock.OrderCreate invocations
func (mmOrderCreate *LomsServiceMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mLomsServiceMockOrderCreate) Calls() []*LomsServiceMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*LomsServiceMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockOrderCreateDone() bool {
	if m.OrderCreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateMock.invocationsDone()
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCreate with params: %#v", *e.params)
		}
	}

	afterOrderCreateCounter := mm_atomic.LoadUint64(&m.afterOrderCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && afterOrderCreateCounter < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServiceMock.OrderCreate")
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCreate with params: %#v", *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && afterOrderCreateCounter < 1 {
		m.t.Error("Expected call to LomsServiceMock.OrderCreate")
	}

	if !m.OrderCreateMock.invocationsDone() && afterOrderCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.OrderCreate but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateMock.expectedInvocations), afterOrderCreateCounter)
	}
}

type mLomsServiceMockStocksInfo struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockStocksInfoExpectation
	expectations       []*LomsServiceMockStocksInfoExpectation

	callArgs []*LomsServiceMockStocksInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServiceMockStocksInfoExpectation specifies expectation struct of the lomsService.StocksInfo
type LomsServiceMockStocksInfoExpectation struct {
	mock      *LomsServiceMock
	params    *LomsServiceMockStocksInfoParams
	paramPtrs *LomsServiceMockStocksInfoParamPtrs
	results   *LomsServiceMockStocksInfoResults
	Counter   uint64
}

// LomsServiceMockStocksInfoParams contains parameters of the lomsService.StocksInfo
type LomsServiceMockStocksInfoParams struct {
	ctx context.Context
	sku model.ProductSku
}

// LomsServiceMockStocksInfoParamPtrs contains pointers to parameters of the lomsService.StocksInfo
type LomsServiceMockStocksInfoParamPtrs struct {
	ctx *context.Context
	sku *model.ProductSku
}

// LomsServiceMockStocksInfoResults contains results of the lomsService.StocksInfo
type LomsServiceMockStocksInfoResults struct {
	u1  uint64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksInfo *mLomsServiceMockStocksInfo) Optional() *mLomsServiceMockStocksInfo {
	mmStocksInfo.optional = true
	return mmStocksInfo
}

// Expect sets up expected params for lomsService.StocksInfo
func (mmStocksInfo *mLomsServiceMockStocksInfo) Expect(ctx context.Context, sku model.ProductSku) *mLomsServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.paramPtrs != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by ExpectParams functions")
	}

	mmStocksInfo.defaultExpectation.params = &LomsServiceMockStocksInfoParams{ctx, sku}
	for _, e := range mmStocksInfo.expectations {
		if minimock.Equal(e.params, mmStocksInfo.defaultExpectation.params) {
			mmStocksInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksInfo.defaultExpectation.params)
		}
	}

	return mmStocksInfo
}

// ExpectCtxParam1 sets up expected param ctx for lomsService.StocksInfo
func (mmStocksInfo *mLomsServiceMockStocksInfo) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServiceMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksInfo
}

// ExpectSkuParam2 sets up expected param sku for lomsService.StocksInfo
func (mmStocksInfo *mLomsServiceMockStocksInfo) ExpectSkuParam2(sku model.ProductSku) *mLomsServiceMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiceMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServiceMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.sku = &sku

	return mmStocksInfo
}

// Inspect accepts an inspector function that has same arguments as the lomsService.StocksInfo
func (mmStocksInfo *mLomsServiceMockStocksInfo) Inspect(f func(ctx context.Context, sku model.ProductSku)) *mLomsServiceMockStocksInfo {
	if mmStocksInfo.mock.inspectFuncStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.StocksInfo")
	}

	mmStocksInfo.mock.inspectFuncStocksInfo = f

	return mmStocksInfo
}

// Return sets up results that will be returned by lomsService.StocksInfo
func (mmStocksInfo *mLomsServiceMockStocksInfo) Return(u1 uint64, err error) *LomsServiceMock {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServiceMockStocksInfoExpectation{mock: mmStocksInfo.mock}
	}
	mmStocksInfo.defaultExpectation.results = &LomsServiceMockStocksInfoResults{u1, err}
	return mmStocksInfo.mock
}

// Set uses given function f to mock the lomsService.StocksInfo method
func (mmStocksInfo *mLomsServiceMockStocksInfo) Set(f func(ctx context.Context, sku model.ProductSku) (u1 uint64, err error)) *LomsServiceMock {
	if mmStocksInfo.defaultExpectation != nil {
		mmStocksInfo.mock.t.Fatalf("Default expectation is already set for the lomsService.StocksInfo method")
	}

	if len(mmStocksInfo.expectations) > 0 {
		mmStocksInfo.mock.t.Fatalf("Some expectations are already set for the lomsService.StocksInfo method")
	}

	mmStocksInfo.mock.funcStocksInfo = f
	return mmStocksInfo.mock
}

// When sets expectation for the lomsService.StocksInfo which will trigger the result defined by the following
// Then helper
func (mmStocksInfo *mLomsServiceMockStocksInfo) When(ctx context.Context, sku model.ProductSku) *LomsServiceMockStocksInfoExpectation {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServiceMock.StocksInfo mock is already set by Set")
	}

	expectation := &LomsServiceMockStocksInfoExpectation{
		mock:   mmStocksInfo.mock,
		params: &LomsServiceMockStocksInfoParams{ctx, sku},
	}
	mmStocksInfo.expectations = append(mmStocksInfo.expectations, expectation)
	return expectation
}

// Then sets up lomsService.StocksInfo return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockStocksInfoExpectation) Then(u1 uint64, err error) *LomsServiceMock {
	e.results = &LomsServiceMockStocksInfoResults{u1, err}
	return e.mock
}

// Times sets number of times lomsService.StocksInfo should be invoked
func (mmStocksInfo *mLomsServiceMockStocksInfo) Times(n uint64) *mLomsServiceMockStocksInfo {
	if n == 0 {
		mmStocksInfo.mock.t.Fatalf("Times of LomsServiceMock.StocksInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksInfo.expectedInvocations, n)
	return mmStocksInfo
}

func (mmStocksInfo *mLomsServiceMockStocksInfo) invocationsDone() bool {
	if len(mmStocksInfo.expectations) == 0 && mmStocksInfo.defaultExpectation == nil && mmStocksInfo.mock.funcStocksInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksInfo.mock.afterStocksInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksInfo implements cart.lomsService
func (mmStocksInfo *LomsServiceMock) StocksInfo(ctx context.Context, sku model.ProductSku) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmStocksInfo.beforeStocksInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksInfo.afterStocksInfoCounter, 1)

	if mmStocksInfo.inspectFuncStocksInfo != nil {
		mmStocksInfo.inspectFuncStocksInfo(ctx, sku)
	}

	mm_params := LomsServiceMockStocksInfoParams{ctx, sku}

	// Record call args
	mmStocksInfo.StocksInfoMock.mutex.Lock()
	mmStocksInfo.StocksInfoMock.callArgs = append(mmStocksInfo.StocksInfoMock.callArgs, &mm_params)
	mmStocksInfo.StocksInfoMock.mutex.Unlock()

	for _, e := range mmStocksInfo.StocksInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmStocksInfo.StocksInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksInfo.StocksInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksInfo.StocksInfoMock.defaultExpectation.params
		mm_want_ptrs := mmStocksInfo.StocksInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockStocksInfoParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksInfo.t.Errorf("LomsServiceMock.StocksInfo got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksInfo.t.Errorf("LomsServiceMock.StocksInfo got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksInfo.t.Errorf("LomsServiceMock.StocksInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksInfo.StocksInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksInfo.t.Fatal("No results are set for the LomsServiceMock.StocksInfo")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmStocksInfo.funcStocksInfo != nil {
		return mmStocksInfo.funcStocksInfo(ctx, sku)
	}
	mmStocksInfo.t.Fatalf("Unexpected call to LomsServiceMock.StocksInfo. %v %v", ctx, sku)
	return
}

// StocksInfoAfterCounter returns a count of finished LomsServiceMock.StocksInfo invocations
func (mmStocksInfo *LomsServiceMock) StocksInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.afterStocksInfoCounter)
}

// StocksInfoBeforeCounter returns a count of LomsServiceMock.StocksInfo invocations
func (mmStocksInfo *LomsServiceMock) StocksInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.beforeStocksInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.StocksInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksInfo *mLomsServiceMockStocksInfo) Calls() []*LomsServiceMockStocksInfoParams {
	mmStocksInfo.mutex.RLock()

	argCopy := make([]*LomsServiceMockStocksInfoParams, len(mmStocksInfo.callArgs))
	copy(argCopy, mmStocksInfo.callArgs)

	mmStocksInfo.mutex.RUnlock()

	return argCopy
}

// MinimockStocksInfoDone returns true if the count of the StocksInfo invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockStocksInfoDone() bool {
	if m.StocksInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksInfoMock.invocationsDone()
}

// MinimockStocksInfoInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockStocksInfoInspect() {
	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.StocksInfo with params: %#v", *e.params)
		}
	}

	afterStocksInfoCounter := mm_atomic.LoadUint64(&m.afterStocksInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksInfoMock.defaultExpectation != nil && afterStocksInfoCounter < 1 {
		if m.StocksInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServiceMock.StocksInfo")
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.StocksInfo with params: %#v", *m.StocksInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksInfo != nil && afterStocksInfoCounter < 1 {
		m.t.Error("Expected call to LomsServiceMock.StocksInfo")
	}

	if !m.StocksInfoMock.invocationsDone() && afterStocksInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.StocksInfo but found %d calls",
			mm_atomic.LoadUint64(&m.StocksInfoMock.expectedInvocations), afterStocksInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCreateInspect()

			m.MinimockStocksInfoInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCreateDone() &&
		m.MinimockStocksInfoDone()
}
