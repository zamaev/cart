// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/pkg/service/cart.cartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements cart.cartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16) (err error)
	inspectFuncAddProduct   func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mCartRepositoryMockAddProduct

	funcClearCart          func(ctx context.Context, userId model.UserId) (err error)
	inspectFuncClearCart   func(ctx context.Context, userId model.UserId)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcGetCart          func(ctx context.Context, userId model.UserId) (c2 model.Cart, err error)
	inspectFuncGetCart   func(ctx context.Context, userId model.UserId)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart

	funcRemoveProduct          func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku) (err error)
	inspectFuncRemoveProduct   func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku)
	afterRemoveProductCounter  uint64
	beforeRemoveProductCounter uint64
	RemoveProductMock          mCartRepositoryMockRemoveProduct
}

// NewCartRepositoryMock returns a mock for cart.cartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mCartRepositoryMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*CartRepositoryMockAddProductParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	m.RemoveProductMock = mCartRepositoryMockRemoveProduct{mock: m}
	m.RemoveProductMock.callArgs = []*CartRepositoryMockRemoveProductParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddProduct struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddProductExpectation
	expectations       []*CartRepositoryMockAddProductExpectation

	callArgs []*CartRepositoryMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockAddProductExpectation specifies expectation struct of the cartRepository.AddProduct
type CartRepositoryMockAddProductExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockAddProductParams
	paramPtrs *CartRepositoryMockAddProductParamPtrs
	results   *CartRepositoryMockAddProductResults
	Counter   uint64
}

// CartRepositoryMockAddProductParams contains parameters of the cartRepository.AddProduct
type CartRepositoryMockAddProductParams struct {
	ctx        context.Context
	userId     model.UserId
	ProductSku model.ProductSku
	count      uint16
}

// CartRepositoryMockAddProductParamPtrs contains pointers to parameters of the cartRepository.AddProduct
type CartRepositoryMockAddProductParamPtrs struct {
	ctx        *context.Context
	userId     *model.UserId
	ProductSku *model.ProductSku
	count      *uint16
}

// CartRepositoryMockAddProductResults contains results of the cartRepository.AddProduct
type CartRepositoryMockAddProductResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mCartRepositoryMockAddProduct) Optional() *mCartRepositoryMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Expect(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &CartRepositoryMockAddProductParams{ctx, userId, ProductSku, count}
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddProduct
}

// ExpectUserIdParam2 sets up expected param userId for cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.userId = &userId

	return mmAddProduct
}

// ExpectProductSkuParam3 sets up expected param ProductSku for cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectProductSkuParam3(ProductSku model.ProductSku) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.ProductSku = &ProductSku

	return mmAddProduct
}

// ExpectCountParam4 sets up expected param count for cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) ExpectCountParam4(count uint16) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.count = &count

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Inspect(f func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16)) *mCartRepositoryMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by cartRepository.AddProduct
func (mmAddProduct *mCartRepositoryMockAddProduct) Return(err error) *CartRepositoryMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartRepositoryMockAddProductExpectation{mock: mmAddProduct.mock}
	}
	mmAddProduct.defaultExpectation.results = &CartRepositoryMockAddProductResults{err}
	return mmAddProduct.mock
}

// Set uses given function f to mock the cartRepository.AddProduct method
func (mmAddProduct *mCartRepositoryMockAddProduct) Set(f func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16) (err error)) *CartRepositoryMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the cartRepository.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the cartRepository.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	return mmAddProduct.mock
}

// When sets expectation for the cartRepository.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mCartRepositoryMockAddProduct) When(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16) *CartRepositoryMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartRepositoryMock.AddProduct mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddProductExpectation{
		mock:   mmAddProduct.mock,
		params: &CartRepositoryMockAddProductParams{ctx, userId, ProductSku, count},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.AddProduct return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddProductExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddProductResults{err}
	return e.mock
}

// Times sets number of times cartRepository.AddProduct should be invoked
func (mmAddProduct *mCartRepositoryMockAddProduct) Times(n uint64) *mCartRepositoryMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of CartRepositoryMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	return mmAddProduct
}

func (mmAddProduct *mCartRepositoryMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements cart.cartRepository
func (mmAddProduct *CartRepositoryMock) AddProduct(ctx context.Context, userId model.UserId, ProductSku model.ProductSku, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(ctx, userId, ProductSku, count)
	}

	mm_params := CartRepositoryMockAddProductParams{ctx, userId, ProductSku, count}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddProductParams{ctx, userId, ProductSku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.ProductSku != nil && !minimock.Equal(*mm_want_ptrs.ProductSku, mm_got.ProductSku) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter ProductSku, want: %#v, got: %#v%s\n", *mm_want_ptrs.ProductSku, mm_got.ProductSku, minimock.Diff(*mm_want_ptrs.ProductSku, mm_got.ProductSku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameter count, want: %#v, got: %#v%s\n", *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("CartRepositoryMock.AddProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProduct.AddProductMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProduct.t.Fatal("No results are set for the CartRepositoryMock.AddProduct")
		}
		return (*mm_results).err
	}
	if mmAddProduct.funcAddProduct != nil {
		return mmAddProduct.funcAddProduct(ctx, userId, ProductSku, count)
	}
	mmAddProduct.t.Fatalf("Unexpected call to CartRepositoryMock.AddProduct. %v %v %v %v", ctx, userId, ProductSku, count)
	return
}

// AddProductAfterCounter returns a count of finished CartRepositoryMock.AddProduct invocations
func (mmAddProduct *CartRepositoryMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of CartRepositoryMock.AddProduct invocations
func (mmAddProduct *CartRepositoryMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mCartRepositoryMockAddProduct) Calls() []*CartRepositoryMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddProduct with params: %#v", *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.AddProduct")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddProduct with params: %#v", *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.AddProduct")
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddProduct but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), afterAddProductCounter)
	}
}

type mCartRepositoryMockClearCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the cartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockClearCartParams
	paramPtrs *CartRepositoryMockClearCartParamPtrs
	results   *CartRepositoryMockClearCartResults
	Counter   uint64
}

// CartRepositoryMockClearCartParams contains parameters of the cartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockClearCartParamPtrs contains pointers to parameters of the cartRepository.ClearCart
type CartRepositoryMockClearCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockClearCartResults contains results of the cartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartRepositoryMockClearCart) Optional() *mCartRepositoryMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for cartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{ctx, userId}
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmClearCart
}

// ExpectUserIdParam2 sets up expected param userId for cartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userId = &userId

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by cartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	return mmClearCart.mock
}

// Set uses given function f to mock the cartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(ctx context.Context, userId model.UserId) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	return mmClearCart.mock
}

// When sets expectation for the cartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(ctx context.Context, userId model.UserId) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:   mmClearCart.mock,
		params: &CartRepositoryMockClearCartParams{ctx, userId},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// Times sets number of times cartRepository.ClearCart should be invoked
func (mmClearCart *mCartRepositoryMockClearCart) Times(n uint64) *mCartRepositoryMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	return mmClearCart
}

func (mmClearCart *mCartRepositoryMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements cart.cartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(ctx context.Context, userId model.UserId) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, userId)
	}

	mm_params := CartRepositoryMockClearCartParams{ctx, userId}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, userId)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v %v", ctx, userId)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart with params: %#v", *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ClearCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart with params: %#v", *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ClearCart")
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearCart but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), afterClearCartCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the cartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockGetCartParams
	paramPtrs *CartRepositoryMockGetCartParamPtrs
	results   *CartRepositoryMockGetCartResults
	Counter   uint64
}

// CartRepositoryMockGetCartParams contains parameters of the cartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the cartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockGetCartResults contains results of the cartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	c2  model.Cart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for cartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, userId}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCart
}

// ExpectUserIdParam2 sets up expected param userId for cartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userId = &userId

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by cartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(c2 model.Cart, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{c2, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the cartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, userId model.UserId) (c2 model.Cart, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the cartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, userId model.UserId) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &CartRepositoryMockGetCartParams{ctx, userId},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(c2 model.Cart, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{c2, err}
	return e.mock
}

// Times sets number of times cartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements cart.cartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, userId model.UserId) (c2 model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userId)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, userId}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userId)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, userId)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart with params: %#v", *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.GetCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.GetCart")
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), afterGetCartCounter)
	}
}

type mCartRepositoryMockRemoveProduct struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveProductExpectation
	expectations       []*CartRepositoryMockRemoveProductExpectation

	callArgs []*CartRepositoryMockRemoveProductParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockRemoveProductExpectation specifies expectation struct of the cartRepository.RemoveProduct
type CartRepositoryMockRemoveProductExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockRemoveProductParams
	paramPtrs *CartRepositoryMockRemoveProductParamPtrs
	results   *CartRepositoryMockRemoveProductResults
	Counter   uint64
}

// CartRepositoryMockRemoveProductParams contains parameters of the cartRepository.RemoveProduct
type CartRepositoryMockRemoveProductParams struct {
	ctx        context.Context
	userId     model.UserId
	ProductSku model.ProductSku
}

// CartRepositoryMockRemoveProductParamPtrs contains pointers to parameters of the cartRepository.RemoveProduct
type CartRepositoryMockRemoveProductParamPtrs struct {
	ctx        *context.Context
	userId     *model.UserId
	ProductSku *model.ProductSku
}

// CartRepositoryMockRemoveProductResults contains results of the cartRepository.RemoveProduct
type CartRepositoryMockRemoveProductResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Optional() *mCartRepositoryMockRemoveProduct {
	mmRemoveProduct.optional = true
	return mmRemoveProduct
}

// Expect sets up expected params for cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Expect(ctx context.Context, userId model.UserId, ProductSku model.ProductSku) *mCartRepositoryMockRemoveProduct {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	if mmRemoveProduct.defaultExpectation == nil {
		mmRemoveProduct.defaultExpectation = &CartRepositoryMockRemoveProductExpectation{}
	}

	if mmRemoveProduct.defaultExpectation.paramPtrs != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by ExpectParams functions")
	}

	mmRemoveProduct.defaultExpectation.params = &CartRepositoryMockRemoveProductParams{ctx, userId, ProductSku}
	for _, e := range mmRemoveProduct.expectations {
		if minimock.Equal(e.params, mmRemoveProduct.defaultExpectation.params) {
			mmRemoveProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveProduct.defaultExpectation.params)
		}
	}

	return mmRemoveProduct
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveProduct {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	if mmRemoveProduct.defaultExpectation == nil {
		mmRemoveProduct.defaultExpectation = &CartRepositoryMockRemoveProductExpectation{}
	}

	if mmRemoveProduct.defaultExpectation.params != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Expect")
	}

	if mmRemoveProduct.defaultExpectation.paramPtrs == nil {
		mmRemoveProduct.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveProductParamPtrs{}
	}
	mmRemoveProduct.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRemoveProduct
}

// ExpectUserIdParam2 sets up expected param userId for cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockRemoveProduct {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	if mmRemoveProduct.defaultExpectation == nil {
		mmRemoveProduct.defaultExpectation = &CartRepositoryMockRemoveProductExpectation{}
	}

	if mmRemoveProduct.defaultExpectation.params != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Expect")
	}

	if mmRemoveProduct.defaultExpectation.paramPtrs == nil {
		mmRemoveProduct.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveProductParamPtrs{}
	}
	mmRemoveProduct.defaultExpectation.paramPtrs.userId = &userId

	return mmRemoveProduct
}

// ExpectProductSkuParam3 sets up expected param ProductSku for cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) ExpectProductSkuParam3(ProductSku model.ProductSku) *mCartRepositoryMockRemoveProduct {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	if mmRemoveProduct.defaultExpectation == nil {
		mmRemoveProduct.defaultExpectation = &CartRepositoryMockRemoveProductExpectation{}
	}

	if mmRemoveProduct.defaultExpectation.params != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Expect")
	}

	if mmRemoveProduct.defaultExpectation.paramPtrs == nil {
		mmRemoveProduct.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveProductParamPtrs{}
	}
	mmRemoveProduct.defaultExpectation.paramPtrs.ProductSku = &ProductSku

	return mmRemoveProduct
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Inspect(f func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku)) *mCartRepositoryMockRemoveProduct {
	if mmRemoveProduct.mock.inspectFuncRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveProduct")
	}

	mmRemoveProduct.mock.inspectFuncRemoveProduct = f

	return mmRemoveProduct
}

// Return sets up results that will be returned by cartRepository.RemoveProduct
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Return(err error) *CartRepositoryMock {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	if mmRemoveProduct.defaultExpectation == nil {
		mmRemoveProduct.defaultExpectation = &CartRepositoryMockRemoveProductExpectation{mock: mmRemoveProduct.mock}
	}
	mmRemoveProduct.defaultExpectation.results = &CartRepositoryMockRemoveProductResults{err}
	return mmRemoveProduct.mock
}

// Set uses given function f to mock the cartRepository.RemoveProduct method
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Set(f func(ctx context.Context, userId model.UserId, ProductSku model.ProductSku) (err error)) *CartRepositoryMock {
	if mmRemoveProduct.defaultExpectation != nil {
		mmRemoveProduct.mock.t.Fatalf("Default expectation is already set for the cartRepository.RemoveProduct method")
	}

	if len(mmRemoveProduct.expectations) > 0 {
		mmRemoveProduct.mock.t.Fatalf("Some expectations are already set for the cartRepository.RemoveProduct method")
	}

	mmRemoveProduct.mock.funcRemoveProduct = f
	return mmRemoveProduct.mock
}

// When sets expectation for the cartRepository.RemoveProduct which will trigger the result defined by the following
// Then helper
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) When(ctx context.Context, userId model.UserId, ProductSku model.ProductSku) *CartRepositoryMockRemoveProductExpectation {
	if mmRemoveProduct.mock.funcRemoveProduct != nil {
		mmRemoveProduct.mock.t.Fatalf("CartRepositoryMock.RemoveProduct mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveProductExpectation{
		mock:   mmRemoveProduct.mock,
		params: &CartRepositoryMockRemoveProductParams{ctx, userId, ProductSku},
	}
	mmRemoveProduct.expectations = append(mmRemoveProduct.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.RemoveProduct return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveProductExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveProductResults{err}
	return e.mock
}

// Times sets number of times cartRepository.RemoveProduct should be invoked
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Times(n uint64) *mCartRepositoryMockRemoveProduct {
	if n == 0 {
		mmRemoveProduct.mock.t.Fatalf("Times of CartRepositoryMock.RemoveProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveProduct.expectedInvocations, n)
	return mmRemoveProduct
}

func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) invocationsDone() bool {
	if len(mmRemoveProduct.expectations) == 0 && mmRemoveProduct.defaultExpectation == nil && mmRemoveProduct.mock.funcRemoveProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveProduct.mock.afterRemoveProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveProduct implements cart.cartRepository
func (mmRemoveProduct *CartRepositoryMock) RemoveProduct(ctx context.Context, userId model.UserId, ProductSku model.ProductSku) (err error) {
	mm_atomic.AddUint64(&mmRemoveProduct.beforeRemoveProductCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveProduct.afterRemoveProductCounter, 1)

	if mmRemoveProduct.inspectFuncRemoveProduct != nil {
		mmRemoveProduct.inspectFuncRemoveProduct(ctx, userId, ProductSku)
	}

	mm_params := CartRepositoryMockRemoveProductParams{ctx, userId, ProductSku}

	// Record call args
	mmRemoveProduct.RemoveProductMock.mutex.Lock()
	mmRemoveProduct.RemoveProductMock.callArgs = append(mmRemoveProduct.RemoveProductMock.callArgs, &mm_params)
	mmRemoveProduct.RemoveProductMock.mutex.Unlock()

	for _, e := range mmRemoveProduct.RemoveProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveProduct.RemoveProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveProduct.RemoveProductMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveProduct.RemoveProductMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveProduct.RemoveProductMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveProductParams{ctx, userId, ProductSku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveProduct.t.Errorf("CartRepositoryMock.RemoveProduct got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveProduct.t.Errorf("CartRepositoryMock.RemoveProduct got unexpected parameter userId, want: %#v, got: %#v%s\n", *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.ProductSku != nil && !minimock.Equal(*mm_want_ptrs.ProductSku, mm_got.ProductSku) {
				mmRemoveProduct.t.Errorf("CartRepositoryMock.RemoveProduct got unexpected parameter ProductSku, want: %#v, got: %#v%s\n", *mm_want_ptrs.ProductSku, mm_got.ProductSku, minimock.Diff(*mm_want_ptrs.ProductSku, mm_got.ProductSku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveProduct.t.Errorf("CartRepositoryMock.RemoveProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveProduct.RemoveProductMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveProduct.t.Fatal("No results are set for the CartRepositoryMock.RemoveProduct")
		}
		return (*mm_results).err
	}
	if mmRemoveProduct.funcRemoveProduct != nil {
		return mmRemoveProduct.funcRemoveProduct(ctx, userId, ProductSku)
	}
	mmRemoveProduct.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveProduct. %v %v %v", ctx, userId, ProductSku)
	return
}

// RemoveProductAfterCounter returns a count of finished CartRepositoryMock.RemoveProduct invocations
func (mmRemoveProduct *CartRepositoryMock) RemoveProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveProduct.afterRemoveProductCounter)
}

// RemoveProductBeforeCounter returns a count of CartRepositoryMock.RemoveProduct invocations
func (mmRemoveProduct *CartRepositoryMock) RemoveProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveProduct.beforeRemoveProductCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveProduct *mCartRepositoryMockRemoveProduct) Calls() []*CartRepositoryMockRemoveProductParams {
	mmRemoveProduct.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveProductParams, len(mmRemoveProduct.callArgs))
	copy(argCopy, mmRemoveProduct.callArgs)

	mmRemoveProduct.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveProductDone returns true if the count of the RemoveProduct invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveProductDone() bool {
	if m.RemoveProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveProductMock.invocationsDone()
}

// MinimockRemoveProductInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveProductInspect() {
	for _, e := range m.RemoveProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveProduct with params: %#v", *e.params)
		}
	}

	afterRemoveProductCounter := mm_atomic.LoadUint64(&m.afterRemoveProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveProductMock.defaultExpectation != nil && afterRemoveProductCounter < 1 {
		if m.RemoveProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.RemoveProduct")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveProduct with params: %#v", *m.RemoveProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveProduct != nil && afterRemoveProductCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.RemoveProduct")
	}

	if !m.RemoveProductMock.invocationsDone() && afterRemoveProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveProduct but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveProductMock.expectedInvocations), afterRemoveProductCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockClearCartInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveProductInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveProductDone()
}
